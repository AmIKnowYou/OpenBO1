//! SPDX-License-Identifier: GPL-3.0-or-later

#ifdef    __UNIMPLEMENTED__

void `dynamic initializer for 'PT_AC_EPS_VEC''()
{
  return Zynamic::Forward<void ()>(L"`dynamic initializer for 'PT_AC_EPS_VEC''")();
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto create_gjkcc_gjk_geom(const float& mins[0x3], const float& maxs[0x3], const int stype, class gjk_collision_visitor* allocator) -> struct gjk_base_t*
{
  return Zynamic::Forward<struct gjk_base_t* (const float&[0x3], const float&[0x3], const int, class gjk_collision_visitor*)>(L"create_gjkcc_gjk_geom")(mins, maxs, stype, allocator);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

public auto gjkcc_info::update_cg(const float* mins, const float* maxs, const bool force) -> void
{
  return Zynamic::Forward<public void (const float*, const float*, const bool)>(L"gjkcc_info::update_cg")(mins, maxs, force);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

public auto gjkcc_info::Lock() -> void
{
  return Zynamic::Forward<public void ()>(L"gjkcc_info::Lock")();
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

public auto gjkcc_info::Unlock() -> void
{
  return Zynamic::Forward<public void ()>(L"gjkcc_info::Unlock")();
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

void `dynamic initializer for 'g_gjkcc_info_allocator''()
{
  return Zynamic::Forward<void ()>(L"`dynamic initializer for 'g_gjkcc_info_allocator''")();
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto create_gjkcc_info(const unsigned int gjkcc_id, const bool is_server_thread, const float* origin) -> struct gjkcc_info*
{
  return Zynamic::Forward<struct gjkcc_info* (const unsigned int, const bool, const float*)>(L"create_gjkcc_info")(gjkcc_id, is_server_thread, origin);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto destroy_gjkcc_info(void* gcci_) -> void
{
  return Zynamic::Forward<void (void*)>(L"destroy_gjkcc_info")(gcci_);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

public auto gjkcc_info_database_t::Lock() -> void
{
  return Zynamic::Forward<public void ()>(L"gjkcc_info_database_t::Lock")();
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

public auto gjkcc_info_database_t::Unlock() -> void
{
  return Zynamic::Forward<public void ()>(L"gjkcc_info_database_t::Unlock")();
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

public auto gjkcc_info_database_t::verify_internal(const bool is_server_thread) -> void
{
  return Zynamic::Forward<public void (const bool)>(L"gjkcc_info_database_t::verify_internal")(is_server_thread);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

public auto gjkcc_info_database_t::gjkcc_info_find_or_create(const unsigned int gjkcc_id, const bool is_server_thread, const float* origin) -> struct gjkcc_info*
{
  return Zynamic::Forward<public struct gjkcc_info* (const unsigned int, const bool, const float*)>(L"gjkcc_info_database_t::gjkcc_info_find_or_create")(gjkcc_id, is_server_thread, origin);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

public auto gjkcc_info_database_t::gjkcc_info_find(const unsigned int gjkcc_id, const bool is_server_thread) -> struct gjkcc_info*
{
  return Zynamic::Forward<public struct gjkcc_info* (const unsigned int, const bool)>(L"gjkcc_info_database_t::gjkcc_info_find")(gjkcc_id, is_server_thread);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

public auto gjkcc_info_database_t::gjkcc_info_destroy(const unsigned int gjkcc_id, const bool is_server_thread) -> void
{
  return Zynamic::Forward<public void (const unsigned int, const bool)>(L"gjkcc_info_database_t::gjkcc_info_destroy")(gjkcc_id, is_server_thread);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

void `dynamic initializer for 'g_gjkcc_info_client_database''()
{
  return Zynamic::Forward<void ()>(L"`dynamic initializer for 'g_gjkcc_info_client_database''")();
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

void `dynamic initializer for 'g_gjkcc_info_server_database''()
{
  return Zynamic::Forward<void ()>(L"`dynamic initializer for 'g_gjkcc_info_server_database''")();
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto find_gjkcc_info(const unsigned int gjkcc_id, const bool is_server_thread) -> struct gjkcc_info*
{
  return Zynamic::Forward<struct gjkcc_info* (const unsigned int, const bool)>(L"find_gjkcc_info")(gjkcc_id, is_server_thread);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto destroy_client_gjkcc_info(int localClientNum) -> void
{
  return Zynamic::Forward<void (int)>(L"destroy_client_gjkcc_info")(localClientNum);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto gjkcc_prolog(const struct gjkcc_input_t& gjkcc_in, const float* origin) -> void
{
  return Zynamic::Forward<void (const struct gjkcc_input_t&, const float*)>(L"gjkcc_prolog")(gjkcc_in, origin);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto gjkcc_epilog(const struct gjkcc_input_t& gjkcc_in, const float* origin) -> void
{
  return Zynamic::Forward<void (const struct gjkcc_input_t&, const float*)>(L"gjkcc_epilog")(gjkcc_in, origin);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

public auto gjk_double_sphere_t::is_foot(const class phys_vec3& hit_point) -> const bool
{
  return Zynamic::Forward<public const bool (const class phys_vec3&)>(L"gjk_double_sphere_t::is_foot")(hit_point);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

public auto gjk_cylinder_t::is_foot(const class phys_vec3& hit_point) -> const bool
{
  return Zynamic::Forward<public const bool (const class phys_vec3&)>(L"gjk_cylinder_t::is_foot")(hit_point);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

public auto gjk_polygon_cylinder_t::is_foot(const class phys_vec3& hit_point) -> const bool
{
  return Zynamic::Forward<public const bool (const class phys_vec3&)>(L"gjk_polygon_cylinder_t::is_foot")(hit_point);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

public auto gjk_brush_t::is_walkable(const class phys_vec3& hit_point, const class phys_vec3& up) -> const bool
{
  return Zynamic::Forward<public const bool (const class phys_vec3&, const class phys_vec3&)>(L"gjk_brush_t::is_walkable")(hit_point, up);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

public auto gjk_partition_t::is_walkable(const class phys_vec3& hit_point, const class phys_vec3& up) -> const bool
{
  return Zynamic::Forward<public const bool (const class phys_vec3&, const class phys_vec3&)>(L"gjk_partition_t::is_walkable")(hit_point, up);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

public auto gjk_trace_input_t::set_cg_position(const class phys_vec3& position) -> void
{
  return Zynamic::Forward<public void (const class phys_vec3&)>(L"gjk_trace_input_t::set_cg_position")(position);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto calc_time(class phys_gjk_info* gjk_info, const bool keep_all_collisions, float* time, float* dist) -> void
{
  return Zynamic::Forward<void (class phys_gjk_info*, const bool, float*, float*)>(L"calc_time")(gjk_info, keep_all_collisions, time, dist);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto POLYGON_CYLINDER_HACK(class phys_gjk_input* pgi, const struct gjk_base_t* cg1, const struct gjk_base_t* cg2) -> void
{
  return Zynamic::Forward<void (class phys_gjk_input*, const struct gjk_base_t*, const struct gjk_base_t*)>(L"POLYGON_CYLINDER_HACK")(pgi, cg1, cg2);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto gjk_collide(class phys_gjk_info* gjk_info, const class phys_gjk_input* pgi, struct gjk_trace_output_t* gto, const struct gjk_trace_input_t& gti, struct gjk_geom_info_t* gi) -> const bool
{
  return Zynamic::Forward<const bool (class phys_gjk_info*, const class phys_gjk_input*, struct gjk_trace_output_t*, const struct gjk_trace_input_t&, struct gjk_geom_info_t*)>(L"gjk_collide")(gjk_info, pgi, gto, gti, gi);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto init_pgi(class phys_gjk_input* pgi, const struct gjk_trace_input_t& gti) -> void
{
  return Zynamic::Forward<void (class phys_gjk_input*, const struct gjk_trace_input_t&)>(L"init_pgi")(pgi, gti);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto set_pgi_cg2(class phys_gjk_input* pgi, const struct gjk_trace_input_t& gti, struct gjk_geom_info_t* gi) -> void
{
  return Zynamic::Forward<void (class phys_gjk_input*, const struct gjk_trace_input_t&, struct gjk_geom_info_t*)>(L"set_pgi_cg2")(pgi, gti, gi);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto sort_gi_list(struct gjk_geom_info_t** list, const int list_count) -> void
{
  return Zynamic::Forward<void (struct gjk_geom_info_t**, const int)>(L"sort_gi_list")(list, list_count);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto gjk_trace(const struct gjk_trace_input_t& gti, struct list_gjk_trace_output* list) -> void
{
  return Zynamic::Forward<void (const struct gjk_trace_input_t&, struct list_gjk_trace_output*)>(L"gjk_trace")(gti, list);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto setup_query_input(const struct gjkcc_input_t& gjkcc_in, const class phys_vec3& aabb_min, const class phys_vec3& aabb_max, const class phys_vec3& position, const class phys_vec3& translation, const int passEntityNum, const int contentMask, struct gjk_query_input& query_input) -> void
{
  return Zynamic::Forward<void (const struct gjkcc_input_t&, const class phys_vec3&, const class phys_vec3&, const class phys_vec3&, const class phys_vec3&, const int, const int, struct gjk_query_input&)>(L"setup_query_input")(gjkcc_in, aabb_min, aabb_max, position, translation, passEntityNum, contentMask, query_input);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto setup_trace_info(const struct gjkcc_input_t& gjkcc_in, const float* start, const float* mins, const float* maxs, const float* end, int passEntityNum, int contentMask, struct gjk_trace_input_t* gti) -> void
{
  return Zynamic::Forward<void (const struct gjkcc_input_t&, const float*, const float*, const float*, const float*, int, int, struct gjk_trace_input_t*)>(L"setup_trace_info")(gjkcc_in, start, mins, maxs, end, passEntityNum, contentMask, gti);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto gjk_player_trace(const struct gjkcc_input_t& gjkcc_in, struct trace_t* results, const float* start, const float* mins, const float* maxs, const float* end, int passEntityNum, int contentMask) -> void
{
  return Zynamic::Forward<void (const struct gjkcc_input_t&, struct trace_t*, const float*, const float*, const float*, const float*, int, int)>(L"gjk_player_trace")(gjkcc_in, results, start, mins, maxs, end, passEntityNum, contentMask);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto no_push_out(const struct gjk_trace_output_t* gto) -> const bool
{
  return Zynamic::Forward<const bool (const struct gjk_trace_output_t*)>(L"no_push_out")(gto);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto set_hit_info(struct geom_plane* gp, const struct gjk_trace_output_t* gto) -> void
{
  return Zynamic::Forward<void (struct geom_plane*, const struct gjk_trace_output_t*)>(L"set_hit_info")(gp, gto);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto add_hit_info(const struct gjk_trace_output_t* gto, class phys_static_array<geom_plane, 128>* list_geom_plane, class phys_link_list<gjk_geom_info_t>* geom_skip_list) -> void
{
  return Zynamic::Forward<void (const struct gjk_trace_output_t*, class phys_static_array<geom_plane,128>*, class phys_link_list<gjk_geom_info_t>*)>(L"add_hit_info")(gto, list_geom_plane, geom_skip_list);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto project_succeeded(class phys_static_array<geom_plane, 128>* list_geom_plane, const class phys_vec3& new_position, const float PROJECT_FAIL_THRESH) -> const bool
{
  return Zynamic::Forward<const bool (class phys_static_array<geom_plane,128>*, const class phys_vec3&, const float)>(L"project_succeeded")(list_geom_plane, new_position, PROJECT_FAIL_THRESH);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto gjk_push_out(const struct gjkcc_input_t& gjkcc_in, const struct gjk_slide_move_input_t& input, struct gjk_slide_move_output_t* output) -> const bool
{
  return Zynamic::Forward<const bool (const struct gjkcc_input_t&, const struct gjk_slide_move_input_t&, struct gjk_slide_move_output_t*)>(L"gjk_push_out")(gjkcc_in, input, output);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto gjk_slide_move1(const struct gjkcc_input_t& gjkcc_in, const struct gjk_slide_move_input_t& input, const bool no_push_out, struct gjk_slide_move_output_t* output, bool* needs_push_out) -> int
{
  return Zynamic::Forward<int (const struct gjkcc_input_t&, const struct gjk_slide_move_input_t&, const bool, struct gjk_slide_move_output_t*, bool*)>(L"gjk_slide_move1")(gjkcc_in, input, no_push_out, output, needs_push_out);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto gjk_slide_move(const struct gjkcc_input_t& gjkcc_in, const struct gjk_slide_move_input_t& input, struct gjk_slide_move_output_t* output) -> int
{
  return Zynamic::Forward<int (const struct gjkcc_input_t&, const struct gjk_slide_move_input_t&, struct gjk_slide_move_output_t*)>(L"gjk_slide_move")(gjkcc_in, input, output);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

public auto query_brush_model_gjk_geom_visitor::visit(const struct CollisionAabbTree* tree) -> void
{
  return Zynamic::Forward<public void (const struct CollisionAabbTree*)>(L"query_brush_model_gjk_geom_visitor::visit")(tree);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto setup_player_push_slide_move_input(struct player_push_slide_move_input_t* input, struct pmove_t* pm, struct pml_t* pml, const class phys_vec3& push_movement) -> void
{
  return Zynamic::Forward<void (struct player_push_slide_move_input_t*, struct pmove_t*, struct pml_t*, const class phys_vec3&)>(L"setup_player_push_slide_move_input")(input, pm, pml, push_movement);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto gjk_sentient_push(struct pmove_t* pm, struct pml_t* pml, const float* origin, const float* mins, const float* maxs, const int contentMask, const int passEntityNum, const struct gjkcc_input_t& gjkcc_in, const float pushRadius, const float frameTime, float* velocity_, float* origin_) -> void
{
  return Zynamic::Forward<void (struct pmove_t*, struct pml_t*, const float*, const float*, const float*, const int, const int, const struct gjkcc_input_t&, const float, const float, float*, float*)>(L"gjk_sentient_push")(pm, pml, origin, mins, maxs, contentMask, passEntityNum, gjkcc_in, pushRadius, frameTime, velocity_, origin_);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto render_gjkcc_collision(const float& mins[0x3], const float& maxs[0x3], const float& origin[0x3]) -> void
{
  return Zynamic::Forward<void (const float&[0x3], const float&[0x3], const float&[0x3])>(L"render_gjkcc_collision")(mins, maxs, origin);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto render_gjkcc_collision(struct pmove_t* pm) -> void
{
  return Zynamic::Forward<void (struct pmove_t*)>(L"render_gjkcc_collision")(pm);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto PM_gjk_ground_trace(const struct gjkcc_input_t& gjkcc_in, struct trace_t* results, const float* start, const float* mins, const float* maxs, const float* end, const int passEntityNum, const int contentMask, float* first_hit_time) -> void
{
  return Zynamic::Forward<void (const struct gjkcc_input_t&, struct trace_t*, const float*, const float*, const float*, const float*, const int, const int, float*)>(L"PM_gjk_ground_trace")(gjkcc_in, results, start, mins, maxs, end, passEntityNum, contentMask, first_hit_time);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto PM_VerifyPronePosition(struct pmove_t* pm, float* vFallbackOrg, float* vFallbackVel) -> int
{
  return Zynamic::Forward<int (struct pmove_t*, float*, float*)>(L"PM_VerifyPronePosition")(pm, vFallbackOrg, vFallbackVel);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto PM_PermuteRestrictiveClipPlanes(const float* velocity, int planeCount, const float* planes[0x3], int* permutation) -> float
{
  return Zynamic::Forward<float (const float*, int, const float*[0x3], int*)>(L"PM_PermuteRestrictiveClipPlanes")(velocity, planeCount, planes, permutation);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

public auto player_gjk_slide_move_input_t::custom_process(struct gjk_trace_output_t* gto) -> void
{
  return Zynamic::Forward<public void (struct gjk_trace_output_t*)>(L"player_gjk_slide_move_input_t::custom_process")(gto);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto setup_player_gjk_slide_move_input(struct player_gjk_slide_move_input_t* input, struct pmove_t* pm, struct pml_t* pml, int gravity) -> void
{
  return Zynamic::Forward<void (struct player_gjk_slide_move_input_t*, struct pmove_t*, struct pml_t*, int)>(L"setup_player_gjk_slide_move_input")(input, pm, pml, gravity);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto PM_SlideMove(struct pmove_t* pm, struct pml_t* pml, int gravity, bool is_step_up) -> int
{
  return Zynamic::Forward<int (struct pmove_t*, struct pml_t*, int, bool)>(L"PM_SlideMove")(pm, pml, gravity, is_step_up);
}

#endif // __UNIMPLEMENTED__
#ifdef    __UNIMPLEMENTED__

auto PM_StepSlideMove(struct pmove_t* pm, struct pml_t* pml, int gravity) -> void
{
  return Zynamic::Forward<void (struct pmove_t*, struct pml_t*, int)>(L"PM_StepSlideMove")(pm, pml, gravity);
}

#endif // __UNIMPLEMENTED__
